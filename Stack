--------------------------------------------------------------------------------
+main_loop()
+NOTE. gdb vuln-----------------------------------------------------------------
|break 95 (read from user starts)
|-------------------------------------------------------------------------------
--------------------------------------------------------------------------------
* Observation: 87 bytes before the start of rdbuf
- this can be checked by printing 88 %X (%08X might not work because of the rdbuf overflow)
|-%08X nor %8X is not enough to print out 88 words of memory
|-> Solution %n$X to create range query (i.e. update GenerateX)
|-> Updated GenerateX.py (From test, 50 90 query overflows but 50 89 does not)
|-> Just noticed that the number of read bytes is randomized, so it will be different from run to run:
- On 88th %X, it prints out 0x58252065 (='%X e') the very beginning of rdbuf
--------------------------------------------------------------------------------
* Observation: from "gdb" it can be confirmed taht locals are closely clustered
(gdb) p/a &user
$5 = 0xbfffef78
(gdb) p/a &pass
$6 = 0xbfffef7c
(gdb) p/a &ulen
$7 = 0xbfffef80
(gdb) p/a &plen
$8 = 0xbfffef84
(gdb) p/a &s
$9 = 0xbfffef88
(gdb) p/a &rdbuf
$10 = 0xbfffef8c
(gdb) p/a &tbuf
$11 = 0xbfffef94
(gdb) p/a &tbufsz
$12 = 0xbfffef90
(gdb) p/a &nread
$13 = 0xbfffef98
--------------------------------------------------------------------------------
* Observation: rdbuf on stack has lower index at lower address
(gdb) p &rdbuf[2]
$1 = 0xbfffea42 "%X\nZ\332\002P\006"
(gdb) p &rdbuf[3]
$2 = 0xbfffea43 "X\nZ\332\002P\006"
--------------------------------------------------------------------------------
* Observation: From the observation above, conclude that "e %X ..." starts printing from high addr to low addr
|-> this is false, because rdbuf is pointer to a location on a stack frame that is created by "alloca()" (man alloca)
|-> following is proof
(gdb) p &rdbuf[2]
$1 = 0xbfffea42 "%X\nZ\332\002P\006"
(gdb) p &rdbuf[3]
$2 = 0xbfffea43 "X\nZ\332\002P\006"
(gdb) p/a &rdbuf
$3 = 0xbfffef8c
(gdb) p/a &rdbuf[0]
$4 = 0xbfffea40
(gdb) p/a &rdbuf[1]
$5 = 0xbfffea41
(gdb) p/a &rdbuf[2]
$6 = 0xbfffea42
(gdb) p/a &rdbuf[3]
$7 = 0xbfffea43
(gdb) p/a &rdbuf[4]
$8 = 0xbfffea44
(gdb) p/a &rdbuf
$9 = 0xbfffef8c
(gdb) p/a &s
$10 = 0xbfffef88
(gdb) print rdbuf
$11 = 0xbfffea40 "e %X\nZ\332\002P\006"
--------------------------------------------------------------------------------
* Observation: location of the $ebp and $esp
(gdb) p $ebp
$1 = (void *) 0xbfffea78 
(gdb) p $esp 
$2 = (void *) 0xbfffe3c0
So basically, from $esp(closer to top of the stack) to $ebp(further from the top of the stack)
is the frame for main_loop()

HIGH ADDRESS!!!

--------------------------------------------------------------------------------

...
+0xbfffea80 0x5
+0xbfffea7c 0x8049f14 (RA=saved eip)
+0xbfffea78 EBP
+0xbfffea74
+0xbfffea70
+0xbfffea6c
*Local variables of main_loop()-------------------------------------------------
+0xbfffea68 nread
+0xbfffea64 tbuf
+0xbfffea60 tbufsz (=309)
+0xbfffea5c rdbuf
+0xbfffea58 s
+0xbfffea54 plen
+0xbfffea50 ulen
+0xbfffea4c pass
+0xbfffea48 user
+0xbfffea44
+0xbfffea40
...

--------------------------------------------------------------------------------

+0xbfffe5e0 rdbuf[208] (NOTE. 0xbfffe5e1=rdbuf[209] not, rdbuf[207]!!!)
...
+0xbfffe510 rdbuf

--------------------------------------------------------------------------------
+0xbfffe4f4 ESP+   = tbuf[308]
...
+0xbfffe3d4 ESP+14 = 0x1e
+0xbfffe3d0 ESP+10 = 0x8
+0xbfffe3cc ESP+c  = 0xb7ff1eaa
+0xbfffe3c8 ESP+8  = 0x1eSAVED BP?? Q: Why is this value 
+0xbfffe3c4 ESP+4  = 0xb7d6858
+0xbfffe3c0 ESP    = 0xb7fff000 (verifies with p/x *0xbfffe3c0 THIS IS "tbuf"!!! since its size is 309(tbufsz)
		   = tbuf[0]
--------------------------------------------------------------------------------
LOW ADDRESS!!!

* Now lets identify the variables
read()
0
rdbuf
s-1

